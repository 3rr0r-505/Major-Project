import os
import json
import yaml
import shutil
import subprocess
from pathlib import Path

class revExploit:
    def __init__(self):
        self.config = self.load_config()
        self.hp_type, self.repo_url, self.req_url = self.determine_honeypot()
        self.tmp_path = Path(__file__).parent / "tmp"
        self.tmp_path.mkdir(exist_ok=True)

    def load_config(self):
        """Loads honeypot configuration from config.json."""
        config_path = Path(__file__).parent.parent / "configs" / "config.json"
        with open(config_path, "r") as file:
            return json.load(file)

    def load_signatures(self):
        """Loads honeypot detection signatures from honeypots.yaml."""
        signature_path = Path(__file__).parent.parent / "configs" / "honeypots.yaml"
        with open(signature_path, "r") as file:
            return yaml.safe_load(file)["honeypots"]

    def determine_honeypot(self):
        """Determines the honeypot type based on port and retrieves repo/req links."""
        port = int(self.config["honeypot_creds"]["ports"])
        mapping = {2222: "Cowrie", 8800: "Conpot", 8080: "Wordpot"}
        honeypots = {hp["name"].lower(): hp for hp in self.load_signatures()}
        hp_type = mapping.get(port, "Unknown").lower()
        return hp_type, honeypots.get(hp_type, {}).get("github"), honeypots.get(hp_type, {}).get("requirements")

    def static_analyzer(self):
        """Clone honeypot repo, analyze with Bandit, print and return results, then remove the folder."""
        if not self.repo_url:
            return "No repository found."

        repo_path = self.tmp_path / self.hp_type
        subprocess.run(["git", "clone", self.repo_url, str(repo_path)], check=True)
        result = subprocess.run(["bandit", "-r", str(repo_path)], capture_output=True, text=True)
        print(result.stdout)
        subprocess.run(["rm", "-rf", str(repo_path)])
        return result.stdout

    def package_analyzer(self):
        """Download requirements file using wget, analyze with Safety, and return results."""
        def get_safety_path():
            """Find the 'safety' binary dynamically, even when running with sudo."""
            safety_bin = shutil.which("safety")  # Check if safety is in PATH
            if safety_bin:
                return safety_bin  # Return the found path

            # If running with sudo, manually check user's pipx path
            user_bin_path = os.path.expanduser("~/.local/bin/safety")
            if os.path.exists(user_bin_path):
                return user_bin_path

            # Last resort: Use pipx
            return None

        if not self.req_url:
            return "No requirements found."

        req_file = self.tmp_path / "requirements.txt"

        # Use wget to download the file
        wget_cmd = ["wget", "-O", str(req_file), self.req_url]
        subprocess.run(wget_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Check if the file was downloaded successfully
        if not req_file.exists():
            return "Failed to download requirements."

        safety_path = get_safety_path()
        if safety_path:
            cmd = [safety_path, "check", "-r", str(req_file)]
        else:
            cmd = "pipx run safety check -r {}".format(req_file)  # Use pipx run as a shell command

        result = subprocess.run(cmd, capture_output=True, text=True, shell=(safety_path is None))
        
        print(result.stdout)  # Print output for debugging
        req_file.unlink()
        return result.stdout if result.stdout.strip() else "No vulnerabilities found."

    def explt(self):
        """Aggregate results from static_analyzer() & package_analyzer() with proper formatting."""
        static_results = self.static_analyzer().splitlines()  # Convert to list of lines
        package_results = self.package_analyzer().splitlines()  # Convert to list of lines
        subprocess.run(["rm", "-rf", str(self.tmp_path)])
        return {"static_analysis": static_results, "package_analysis": package_results}

